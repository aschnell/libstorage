// Maintainer: fehr@suse.de

#include <ycp/y2log.h>

#include <sstream>

#include "y2storage/AppUtil.h"
#include "y2storage/Regex.h"
#include "y2storage/EtcRaidtab.h"
#include "y2storage/AsciiFile.h"
#include "y2storage/Md.h"

EtcRaidtab::EtcRaidtab( const string& prefix ) 
    {
    mdadm_dev_line = -1;
    rtabname = prefix+"/etc/raidtab";
    mdadmname = prefix+"/etc/mdadm.conf";
    comment = new Regex( "^[ \t]*#" );
    whitespace = new Regex( "^[ \t]*$" );
    raidtab = new AsciiFile( rtabname );
    mdadm = new AsciiFile( mdadmname ); 
    buildRaidtabMap();
    buildMdadmMap();
    }

EtcRaidtab::~EtcRaidtab()
    {
    delete whitespace;
    delete comment;
    delete raidtab;
    delete mdadm;
    }

void 
EtcRaidtab::updateEntry( unsigned num, const list<string>& entries,
                         const string& mline, const list<string>& devs )
    {
    y2milestone( "num:%u", num );
    map<unsigned,entry>::iterator i = rtab.find( num );
    if( i != rtab.end() )
	{
	raidtab->replace( i->second.first, i->second.last-i->second.first+1, entries );
	}
    else
	{
	if( raidtab->numLines()==0 )
	    {
	    raidtab->append( "# autogenerated /etc/raidtab by YaST2" );
	    raidtab->append( "" );
	    }
	else
	    {
	    if( (*raidtab)[raidtab->numLines()-1].find_first_not_of( app_ws ) != string::npos )
		raidtab->append( "" );
	    }
	raidtab->append( entries );
	}
    string dline;
    i = mtab.find( num );
    if( i != mtab.end() )
	{
	mdadm->replace( i->second.first, i->second.last-i->second.first+1, mline );
	}
    else
	{
	mdadm->append( mline );
	}
    if( mdadm_dev_line<0 )
	{
	dline = "DEVICE";
	for( list<string>::const_iterator i=devs.begin(); i!=devs.end(); i++ )
	    dline += " " + *i;
	mdadm_dev_line = mdadm->numLines();
	mdadm->insert( 0, dline );
	}
    else
	{
	dline = (*mdadm)[mdadm_dev_line];
	list<string> d = splitString( dline );
	for( list<string>::const_iterator i=devs.begin(); i!=devs.end(); i++ )
	    if( find( d.begin(), d.end(), *i )==d.end() )
		dline += " " + *i;
	(*mdadm)[mdadm_dev_line] = dline;
	}
    updateRaidtabFile();
    updateMdadmFile();
    }

void
EtcRaidtab::removeEntry( unsigned num )
    {
    map<unsigned,entry>::iterator i = rtab.find( num );
    if( i != rtab.end() )
	{
	raidtab->remove( i->second.first, i->second.last-i->second.first+1 );
	if( i != rtab.begin() )
	    {
	    unsigned lineno=i->second.first-1;
	    while( (comment->match( (*raidtab)[lineno] ) ||
		    whitespace->match( (*raidtab)[lineno] )) && lineno>0 )
		lineno--;
	    if( lineno<i->second.first-1 )
		raidtab->remove( lineno, i->second.first-lineno );
	    }
	updateRaidtabFile();
	}
    i = mtab.find( num );
    if( i != mtab.end() )
	{
	mdadm->remove( i->second.first, i->second.last-i->second.first+1 );
	updateMdadmFile();
	}
    }

void
EtcRaidtab::updateRaidtabFile()
    {
    rtab.clear();
    if( raidtab->numLines()==0 && access( rtabname.c_str(), R_OK )==0 )
	unlink( rtabname.c_str() );
    else
	{
	raidtab->updateFile();
	raidtab->loadFile( rtabname );
	}
    buildRaidtabMap();
    }

void
EtcRaidtab::updateMdadmFile()
    {
    mtab.clear();
    mdadm->updateFile();
    mdadm->loadFile( mdadmname );
    buildMdadmMap();
    }

void
EtcRaidtab::buildRaidtabMap()
    {
    unsigned lineno = 0;
    unsigned mdnum;
    entry e;
    while( lineno<raidtab->numLines() )
	{
	if( extractNthWord( 0, (*raidtab)[lineno] ) == "raiddev" &&
	    Md::mdStringNum( extractNthWord( 1, (*raidtab)[lineno] ), mdnum ))
	    {
	    e.first = lineno++;
	    while( lineno<raidtab->numLines() && 
		    extractNthWord( 0, (*raidtab)[lineno] ) != "raiddev" ) 
		lineno++;
	    unsigned tmpl = lineno-1;
	    while( (comment->match( (*raidtab)[tmpl] ) ||
	            whitespace->match( (*raidtab)[tmpl] )) && tmpl>e.first )
		tmpl--;
	    if( tmpl>e.first )
		{
		e.last = tmpl;
		rtab[mdnum] = e;
		}
	    }
	else
	    lineno++;
	}
    }

void
EtcRaidtab::buildMdadmMap()
    {
    unsigned lineno = 0;
    unsigned mdnum;
    mdadm_dev_line = -1;
    entry e;
    while( lineno<mdadm->numLines() )
	{
	string key = extractNthWord( 0, (*mdadm)[lineno] );
	if( mdadm_dev_line<0 && key == "DEVICE"  )
	    mdadm_dev_line = lineno;
	else if( key == "ARRAY" &&
		 Md::mdStringNum( extractNthWord( 1, (*mdadm)[lineno] ), mdnum ))
	    {
	    e.first = lineno++;
	    while( lineno<mdadm->numLines() && 
	           (key = extractNthWord( 0, (*mdadm)[lineno] ))!="ARRAY" &&
		   key != "DEVICE" )
		{
		key = extractNthWord( 0, (*mdadm)[lineno++] );
		}
	    e.last = lineno-1;
	    mtab[mdnum] = e;
	    }
	else
	    lineno++;
	}
    }
