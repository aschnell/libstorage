// Maintainer: fehr@suse.de

#include <ycp/y2log.h>

#include <sstream>

#include "y2storage/AppUtil.h"
#include "y2storage/Regex.h"
#include "y2storage/EtcRaidtab.h"
#include "y2storage/Md.h"

EtcRaidtab::EtcRaidtab( const string& prefix ) 
    : AsciiFile( prefix+"/etc/raidtab" )
    {
    filename = prefix+"/etc/raidtab";
    comment = new Regex( "^[ \t]*#" );
    whitespace = new Regex( "^[ \t]*$" );
    buildMap();
    }

EtcRaidtab::~EtcRaidtab()
    {
    delete whitespace;
    delete comment;
    }

void 
EtcRaidtab::updateEntry( unsigned num, const list<string>& entries )
    {
    map<unsigned,entry>::iterator i = co.find( num );
    if( i != co.end() )
	{
	replace( i->second.first, i->second.last-i->second.first+1, entries );
	}
    else
	{
	if( numLines()==0 )
	    {
	    append( "# autogenerated /etc/raidtab by YaST2" );
	    append( "" );
	    }
	else
	    {
	    if( Lines_C.back().find_first_not_of( app_ws ) != string::npos )
		append( "" );
	    }
	append( entries );
	}
    updateFile();
    }

void
EtcRaidtab::removeEntry( unsigned num )
    {
    map<unsigned,entry>::iterator i = co.find( num );
    if( i != co.end() )
	{
	if( co.size()>1 )
	    {
	    remove( i->second.first, i->second.last-i->second.first+1 );
	    if( i != co.begin() )
		{
		unsigned lineno=i->second.first-1;
		while( (comment->match( (*this)[lineno] ) ||
			whitespace->match( (*this)[lineno] )) && lineno>0 )
		    lineno--;
		if( lineno<i->second.first-1 )
		    remove( lineno, i->second.first-lineno );
		}
	    }
	else
	    remove( 0, numLines() );
	updateFile();
	}
    }

void
EtcRaidtab::updateFile()
    {
    co.clear();
    if( numLines()==0 && access( filename.c_str(), R_OK )==0 )
	unlink( filename.c_str() );
    else
	{
	AsciiFile::updateFile();
	loadFile( filename );
	buildMap();
	}
    }

void
EtcRaidtab::buildMap()
    {
    unsigned lineno = 0;
    unsigned mdnum;
    entry e;
    while( lineno<numLines() )
	{
	if( extractNthWord( 0, (*this)[lineno] ) == "raiddev" &&
	    Md::mdStringNum( extractNthWord( 1, (*this)[lineno] ), mdnum ))
	    {
	    e.first = lineno++;
	    while( lineno<numLines() && 
		    extractNthWord( 0, (*this)[lineno] ) != "raiddev" ) 
		lineno++;
	    unsigned tmpl = lineno-1;
	    while( (comment->match( (*this)[tmpl] ) ||
	            whitespace->match( (*this)[tmpl] )) && tmpl>e.first )
		tmpl--;
	    if( tmpl>e.first )
		{
		e.last = tmpl;
		co[mdnum] = e;
		}
	    }
	else
	    lineno++;
	}
    }
