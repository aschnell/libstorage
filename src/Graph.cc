/*
 *  Author: Arvin Schnell <aschnell@suse.de>
 */


#include <string>
#include <fstream>
#include <array>
#include <boost/algorithm/string.hpp>

#include "config.h"
#include "y2storage/Graph.h"


using namespace std;
using namespace storage;


namespace storage
{
    enum Rank { RANK_NONE, RANK_DISK, RANK_PARTITION, RANK_MD, RANK_LVMVG, RANK_LVMLV,
		RANK_MOUNTPOINT };
    typedef array<Rank, 6> Ranks;
    const Ranks ranks = { { RANK_DISK, RANK_PARTITION, RANK_MD, RANK_LVMVG, RANK_LVMLV,
			    RANK_MOUNTPOINT } };

    struct Node
    {
	Node(const string& id, Rank rank, const string& label, const string& attributes = "")
	    : id(id), rank(rank), label(label), attributes(attributes)
	    {}

	string id;
	Rank rank;
	string label;
	string attributes;
    };

    struct Edge
    {
	Edge(const string& id1, const string& id2, const string& attributes = "")
	    : id1(id1), id2(id2), attributes(attributes)
	    {}

	string id1;
	string id2;
	string attributes;
    };

    string dotQuote(const string& str)
    {
	return '"' + boost::replace_all_copy(str, "\"", "\\\"") + '"';
    }

    std::ostream& operator<<(std::ostream& s, const Node& node)
    {
	s << dotQuote(node.id) << " [label=" << dotQuote(node.label);
	if (!node.attributes.empty())
	    s << ", " << node.attributes;
	return s << "];";
    }

    std::ostream& operator<<(std::ostream& s, const Edge& edge)
    {
	s << dotQuote(edge.id1) << " -> " << dotQuote(edge.id2);
	if (!edge.attributes.empty())
	    s << " [" << edge.attributes << "]";
	return s << ";";
    }


    bool
    saveGraph(StorageInterface* s, const string& filename)
    {
	list<Node> nodes;
	list<Edge> edges;


	deque<ContainerInfo> containers;
	s->getContainers(containers);
	for (deque<ContainerInfo>::iterator i1 = containers.begin();
	     i1 != containers.end(); ++i1)
	{
	    switch (i1->type)
	    {
		case DISK: {

		    Node disk_node("device:" + i1->device, RANK_DISK, i1->device);
		    nodes.push_back(disk_node);

		    if (!i1->usedByDevice.empty())
		    {
			edges.push_back(Edge(disk_node.id, "device:" + i1->usedByDevice));
		    }

		    deque<PartitionInfo> partitions;
		    s->getPartitionInfo(i1->name, partitions);
		    for (deque<PartitionInfo>::iterator i2 = partitions.begin();
			 i2 != partitions.end(); ++i2)
		    {
			if (i2->partitionType == EXTENDED)
			    continue;

			Node partition_node("device:" + i2->v.device, RANK_PARTITION, i2->v.device);
			nodes.push_back(partition_node);

			edges.push_back(Edge(disk_node.id, partition_node.id));

			if (!i2->v.usedByDevice.empty())
			{
			    edges.push_back(Edge(partition_node.id, "device:" + i2->v.usedByDevice, "color=green"));
			}

			if (!i2->v.mount.empty())
			{
			    Node mountpoint_node("mountpoint:" + i2->v.mount, RANK_MOUNTPOINT, i2->v.mount);
			    nodes.push_back(mountpoint_node);

			    edges.push_back(Edge(partition_node.id, mountpoint_node.id, "color=blue"));
			}
		    }

		} break;

		case LVM: {

		    Node vg_node("device:" + i1->device, RANK_LVMVG, i1->device);
		    nodes.push_back(vg_node);

		    deque<LvmLvInfo> lvs;
		    s->getLvmLvInfo(i1->name, lvs);
		    for (deque<LvmLvInfo>::iterator i2 = lvs.begin();
			 i2 != lvs.end(); ++i2)
		    {
			Node lv_node("device:" + i2->v.device, RANK_LVMLV, i2->v.device);
			nodes.push_back(lv_node);

			edges.push_back(Edge(vg_node.id, lv_node.id));

			if (!i2->v.mount.empty())
			{
			    Node mountpoint_node("mountpoint:" + i2->v.mount, RANK_MOUNTPOINT, i2->v.mount);
			    nodes.push_back(mountpoint_node);

			    edges.push_back(Edge(lv_node.id, mountpoint_node.id));
			}
		    }

		} break;

		case MD: {

		    deque<MdInfo> mds;
		    s->getMdInfo(mds);

		    for (deque<MdInfo>::iterator i2 = mds.begin(); i2 != mds.end(); ++i2)
		    {
			Node md_node("device:" + i2->v.device, RANK_MD, i2->v.device, "color=red, fillcolor=yellow");
			nodes.push_back(md_node);

			if (!i2->v.usedByDevice.empty())
			{
			    edges.push_back(Edge(md_node.id, "device:" + i2->v.usedByDevice));
			}

			if (!i2->v.mount.empty())
			{
			    Node mountpoint_node("mountpoint:" + i2->v.mount, RANK_MOUNTPOINT, i2->v.mount);
			    nodes.push_back(mountpoint_node);

			    edges.push_back(Edge(md_node.id, mountpoint_node.id));
			}
		    }

		} break;

	    }
	}


	ofstream out(filename.c_str());

	out << "// generated by YaST (" << PACKAGE_STRING << ")" << endl;

	out << "digraph storage" << endl;
	out << "{" << endl;
	out << "    node [shape=rectangle, style=filled, fontname=Helvetica];" << endl;
	out << endl;

	for (list<Node>::const_iterator node = nodes.begin(); node != nodes.end(); ++node)
	    out << "    " << (*node) << endl;

	out << endl;

	for (Ranks::const_iterator rank = ranks.begin(); rank != ranks.end(); ++rank)
	{
	    list<string> ids;
	    for (list<Node>::const_iterator node = nodes.begin(); node != nodes.end(); ++node)
		if (node->rank == *rank)
		    ids.push_back(dotQuote(node->id));

	    if (!ids.empty())
		out << "    { rank=same; " << boost::join(ids, " ") << " };" << endl;
	}
	out << endl;

	for (list<Edge>::const_iterator edge = edges.begin(); edge != edges.end(); ++edge)
	    out << "    " << (*edge) << endl;

	out << "}" << endl;

	out.close();

	return !out.bad();
    }

}
